class CapCutStyleGenerator {
    constructor(pixiContainerId, statusElementId) {
        this.pixiContainerId = pixiContainerId;
        this.statusElementId = statusElementId;
        this.app = null; this.subtitles = []; this.images = []; this.currentSubtitleIndex = 0;
        this.startTime = 0; this.isPlaying = false; this.imageContainer = null; this.mediaRecorder = null;
        this.recordedChunks = []; this.canvasWidth = 405; this.canvasHeight = 720;
        this.transitionSpeed = 0.7; this.blurIntensity = 8; this.safetyZoom = 1.25;
        this.continuousIntensity = 0.6; this.currentSprite = null; this.isTransitioning = false;
        this.continuousAnimationTime = 0; this.baseImageScale = 1; this.baseImageX = 0;
        this.baseImageY = 0; this.lastImageIndex = -1; this.currentAnimationType = null;
        this.animationPhase = 0; this.animationSpeed = 1; this.animationAmplitude = 1;
        this.isSeeking = false; this.audioElement = null;
        this.transitionTypes = ['smoothSlideLeft', 'smoothSlideRight', 'smoothSlideUp', 'smoothSlideDown', 'zoomCrossfade', 'rotateZoom', 'scaleSlide', 'blurCrossfade', 'explosiveZoomIn', 'explosiveZoomOut', 'spiralBlur', 'waveSlide', 'liquidMorph', 'shatterTransition', 'windBlur', 'orbitalSlide', 'shearSlideLeft', 'shearSlideRight', 'shearSlideUp', 'shearSlideDown'];
        this.continuousAnimations = ['gentleDrift', 'smoothFloat', 'gentleSpin', 'breathingZoom', 'orbitalDrift', 'magneticPendulum', 'pulseWave', 'elasticFloat', 'focalDrift', 'hypnoticSpin', 'liquidBreathing', 'cosmicDrift', 'heartbeat', 'windSway', 'oceanWave'];
    }

    async init() {
        try {
            this.app = new PIXI.Application({ width: this.canvasWidth, height: this.canvasHeight, backgroundColor: 0x000000, antialias: true, resolution: 2 });
            const pixiContainer = document.getElementById(this.pixiContainerId);
            if (pixiContainer) {
                pixiContainer.innerHTML = '';
                pixiContainer.appendChild(this.app.view);
            } else { return console.error(`Cont√™iner #${this.pixiContainerId} n√£o encontrado.`); }
            this.imageContainer = new PIXI.Container();
            this.app.stage.addChild(this.imageContainer);
            this.updateStatus('‚úÖ Motor de v√≠deo pronto!');
        } catch (error) { console.error('Erro na inicializa√ß√£o do PixiJS:', error); this.updateStatus('‚ùå Erro no motor de v√≠deo.'); }
    }

    updateStatus(message) { const statusEl = document.getElementById(this.statusElementId); if (statusEl) statusEl.textContent = message; }

    async loadAssets(imageDataUrls, audioBlobUrl) {
        if (!imageDataUrls || imageDataUrls.length === 0 || !audioBlobUrl) { throw new Error('Dados de imagens ou √°udio ausentes!'); }
        this.updateStatus('üñºÔ∏è Carregando imagens...');
        this.images = await this.loadImagesFromDataUrls(imageDataUrls);
        this.audioElement = new Audio(audioBlobUrl);
        await new Promise(resolve => this.audioElement.onloadedmetadata = resolve);
        this.updateStatus(`‚úÖ ${this.images.length} imagens e √°udio carregados.`);
    }

    parseSRT(srtContent) {
        const blocks = srtContent.trim().split(/\n\s*\n/);
        this.subtitles = [];
        for (let block of blocks) {
            const lines = block.trim().split('\n');
            if (lines.length < 2) continue;
            try {
                const timeRange = lines[1];
                const text = lines.slice(2).join(' ').trim();
                const [startStr, endStr] = timeRange.split(' --> ');
                const startTime = this.parseSrtTime(startStr.trim());
                const endTime = this.parseSrtTime(endStr.trim());
                this.subtitles.push({ startTime, endTime, text });
            } catch (e) { console.warn("Bloco SRT inv√°lido ignorado:", block); }
        }
        if (this.subtitles.length === 0) throw new Error('Nenhuma legenda v√°lida encontrada no conte√∫do SRT.');
    }

    async exportVideo(onFinishCallback) {
        if (!this.app || !this.audioElement || this.images.length === 0) { return alert('Motor n√£o est√° pronto.'); }
        let audioCtx = null;
        try {
            audioCtx = new AudioContext();
            const source = audioCtx.createMediaElementSource(this.audioElement);
            const dest = audioCtx.createMediaStreamDestination();
            source.connect(dest);
            const audioStream = dest.stream;
            const videoStream = this.app.view.captureStream(30);
            const combinedStream = new MediaStream([videoStream.getVideoTracks()[0], audioStream.getAudioTracks()[0]]);
            this.mediaRecorder = new MediaRecorder(combinedStream, { mimeType: 'video/webm;codecs=vp9,opus' });
            this.recordedChunks = [];
            this.mediaRecorder.ondataavailable = (event) => { if (event.data.size > 0) this.recordedChunks.push(event.data); };
            this.mediaRecorder.onstop = () => {
                const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
                if (blob.size === 0) { alert("Erro: grava√ß√£o resultou em v√≠deo vazio."); if(onFinishCallback) onFinishCallback(null); return; }
                const finalVideoUrl = URL.createObjectURL(blob);
                if (onFinishCallback) onFinishCallback(finalVideoUrl);
                this.pause();
                if (audioCtx && audioCtx.state !== 'closed') audioCtx.close();
            };
            await this.audioElement.play();
            this.play();
            this.mediaRecorder.start();
            this.updateStatus('üé• Gravando...');
            const totalDuration = this.audioElement.duration * 1000;
            setTimeout(() => { if (this.mediaRecorder?.state === "recording") this.mediaRecorder.stop(); }, totalDuration + 1000);
        } catch (error) {
            console.error('Erro na exporta√ß√£o:', error);
            this.updateStatus('‚ùå Erro na exporta√ß√£o.');
            if (audioCtx && audioCtx.state !== 'closed') audioCtx.close();
        }
    }

    async loadImagesFromDataUrls(dataUrls) { const images = []; for (let i = 0; i < dataUrls.length; i++) { try { const texture = await PIXI.Assets.load(dataUrls[i]); images.push({ texture, name: `image_${i}.jpg` }); this.updateStatus(`‚úÖ Imagem ${i + 1}/${dataUrls.length}`); } catch (error) { throw new Error(`Erro ao carregar imagem ${i + 1}: ${error.message}`); } } return images; }
    parseSrtTime(timeStr) { const [time, ms] = timeStr.split(','); const [h, m, s] = time.split(':').map(Number); return h * 3600 + m * 60 + s + (parseInt(ms) / 1000); }
    play() { this.imageContainer.removeChildren(); this.currentSprite = null; this.lastImageIndex = -1; this.isSeeking = false; this.isPlaying = true; this.startTime = Date.now(); this.currentSubtitleIndex = 0; this.animate(); this.animateContinuous(); }
    pause() { this.isPlaying = false; }
    animate() { if (!this.isPlaying) return; const currentTime = (Date.now() - this.startTime) / 1000; if (this.currentSubtitleIndex < this.subtitles.length) { const nextSub = this.subtitles[this.currentSubtitleIndex]; if (currentTime >= nextSub.startTime && !this.isSeeking) { this.isSeeking = true; const imageIndex = Math.min(this.currentSubtitleIndex, this.images.length - 1); this.showImage(imageIndex).then(() => { this.currentSubtitleIndex++; this.isSeeking = false; }); } } else { const lastSub = this.subtitles[this.subtitles.length - 1]; if (lastSub && currentTime > lastSub.endTime + 0.5) { this.pause(); return; } } requestAnimationFrame(() => this.animate()); }
    async showImage(imageIndex) { const nextImage = this.images[imageIndex]; if (!nextImage?.texture) return; if (this.lastImageIndex !== imageIndex) { this.setRandomAnimationForCurrentImage(); if (this.currentSprite) { const currentImage = this.images[Math.max(0, this.lastImageIndex)]; const transitionType = this.transitionTypes[Math.floor(Math.random() * this.transitionTypes.length)]; await this.performTransition(currentImage, nextImage, transitionType); } else { const data = this.createSafeSprite(nextImage.texture); this.imageContainer.addChild(data.sprite); this.currentSprite = data.sprite; this.baseImageScale = data.baseScale; this.baseImageX = data.baseX; this.baseImageY = data.baseY; this.applyCurrentAnimation(); } this.lastImageIndex = imageIndex; } }
    animateContinuous() { if (!this.isPlaying) return; if (this.currentSprite && !this.isTransitioning && this.currentAnimationType) { this.continuousAnimationTime += 0.016 * this.animationSpeed; this.applyCurrentAnimation(); } requestAnimationFrame(() => this.animateContinuous()); }
    applyCurrentAnimation() { if (!this.currentAnimationType || !this.currentSprite) return; const values = this.calculateAnimationValues(this.currentAnimationType); this.currentSprite.scale.set(values.scale); this.currentSprite.x = values.x; this.currentSprite.y = values.y; this.currentSprite.rotation = values.rotation; this.currentSprite.skew.set(values.skew.x, values.skew.y); }
    setRandomAnimationForCurrentImage() { const oldAnimation = this.currentAnimationType; let newAnimation = oldAnimation; if (this.continuousAnimations.length > 1) { while (newAnimation === oldAnimation) { newAnimation = this.continuousAnimations[Math.floor(Math.random() * this.continuousAnimations.length)]; } } else { newAnimation = this.continuousAnimations[0]; } this.currentAnimationType = newAnimation; this.continuousAnimationTime = 0; this.animationPhase = Math.random() * Math.PI * 2; this.animationSpeed = 0.8 + Math.random() * 0.4; this.animationAmplitude = 0.7 + Math.random() * 0.6; }
    createSafeSprite(texture, extraZoom = 1) { const sprite = new PIXI.Sprite(texture); const scale = Math.max(this.canvasWidth / texture.width, this.canvasHeight / texture.height) * this.safetyZoom * extraZoom; sprite.scale.set(scale); sprite.anchor.set(0.5); sprite.x = this.canvasWidth / 2; sprite.y = this.canvasHeight / 2; return { sprite, baseScale: scale, baseX: sprite.x, baseY: sprite.y }; }
    async performTransition(fromImage, toImage, transitionType) { return new Promise((resolve) => { this.isTransitioning = true; this.imageContainer.removeChildren(); const fromData = this.createSafeSprite(fromImage.texture); const toData = this.createSafeSprite(toImage.texture); this.imageContainer.addChild(fromData.sprite); this.imageContainer.addChild(toData.sprite); this.setupTransitionInitialState(fromData, toData, transitionType); const startTime = Date.now(); const duration = this.transitionSpeed * 1000; const animate = () => { const elapsed = Date.now() - startTime; let progress = Math.min(elapsed / duration, 1); progress = this.getTransitionEasing(transitionType, progress); this.applyTransitionAnimation(fromData, toData, transitionType, progress); if (elapsed < duration) { requestAnimationFrame(animate); } else { this.imageContainer.removeChild(fromData.sprite); this.currentSprite = toData.sprite; this.baseImageScale = toData.baseScale; this.baseImageX = toData.baseX; this.baseImageY = toData.baseY; this.applyCurrentAnimation(); this.isTransitioning = false; resolve(); } }; animate(); }); }
    applyTransitionAnimation(fromData, toData, transitionType, progress) { const { sprite: fromSprite, baseX: fromX, baseY: fromY, baseScale: fromScale } = fromData; const { sprite: toSprite, baseX: toX, baseY: toY, baseScale: toScale } = toData; const dynamicZoom = 1 + 0.8 * Math.sin(progress * Math.PI); switch (transitionType) { case 'smoothSlideLeft': fromSprite.x = fromX - (this.canvasWidth * progress); toSprite.x = (toX + this.canvasWidth) - (this.canvasWidth * progress); fromSprite.alpha = 1 - progress * 0.7; toSprite.alpha = progress; fromSprite.scale.set(fromScale * dynamicZoom); toSprite.scale.set(toScale * dynamicZoom); break; case 'smoothSlideRight': fromSprite.x = fromX + (this.canvasWidth * progress); toSprite.x = (toX - this.canvasWidth) + (this.canvasWidth * progress); fromSprite.alpha = 1 - progress * 0.7; toSprite.alpha = progress; fromSprite.scale.set(fromScale * dynamicZoom); toSprite.scale.set(toScale * dynamicZoom); break; case 'smoothSlideUp': fromSprite.y = fromY - (this.canvasHeight * progress); toSprite.y = (toY + this.canvasHeight) - (this.canvasHeight * progress); fromSprite.alpha = 1 - progress * 0.7; toSprite.alpha = progress; fromSprite.scale.set(fromScale * dynamicZoom); toSprite.scale.set(toScale * dynamicZoom); break; case 'smoothSlideDown': fromSprite.y = fromY + (this.canvasHeight * progress); toSprite.y = (toY - this.canvasHeight) + (this.canvasHeight * progress); fromSprite.alpha = 1 - progress * 0.7; toSprite.alpha = progress; fromSprite.scale.set(fromScale * dynamicZoom); toSprite.scale.set(toScale * dynamicZoom); break; case 'zoomCrossfade': fromSprite.scale.set(fromScale * (1 + progress * 0.3) * dynamicZoom); fromSprite.alpha = 1 - progress; toSprite.scale.set(((toScale * 0.8) + (toScale * 0.2 * progress)) * dynamicZoom); toSprite.alpha = progress; break; case 'rotateZoom': fromSprite.rotation = progress * Math.PI * 0.2; fromSprite.scale.set(fromScale * (1 + progress * 0.2) * dynamicZoom); fromSprite.alpha = 1 - progress; toSprite.scale.set(((toScale * 0.7) + (toScale * 0.3 * progress)) * dynamicZoom); toSprite.rotation = (1 - progress) * Math.PI * 0.5; toSprite.alpha = progress; break; case 'scaleSlide': fromSprite.x = fromX - (this.canvasWidth * progress * 0.3); fromSprite.scale.set(fromScale * (1 - progress * 0.2) * dynamicZoom); fromSprite.alpha = 1 - progress; toSprite.x = (toX + this.canvasWidth * 0.5) - (this.canvasWidth * 0.5 * progress); toSprite.scale.set(((toScale * 0.6) + (toScale * 0.4 * progress)) * dynamicZoom); toSprite.alpha = progress; break; case 'blurCrossfade': fromSprite.scale.set(fromScale * (1 + Math.sin(progress * Math.PI) * this.blurIntensity * 0.1) * dynamicZoom); fromSprite.alpha = 1 - progress; toSprite.scale.set(((toScale * 1.1) - (toScale * 0.1 * progress)) * (1 + Math.sin(progress * Math.PI) * this.blurIntensity * 0.05) * dynamicZoom); toSprite.alpha = progress; break; case 'explosiveZoomIn': fromSprite.alpha = 1 - progress; fromSprite.scale.set(fromScale * (1 + progress * 0.5) * dynamicZoom); fromSprite.rotation = progress * Math.PI * 0.5; toSprite.scale.set(((toScale * 0.1) + (toScale * 0.9 * progress)) * dynamicZoom); toSprite.alpha = progress; toSprite.rotation = (1 - progress) * Math.PI * 2; break; case 'explosiveZoomOut': fromSprite.alpha = 1 - progress; fromSprite.scale.set(fromScale * (1 - progress * 0.2) * dynamicZoom); const targetScale = (toScale * 3 * (1 - progress)) + (toScale * progress); toSprite.scale.set(targetScale * dynamicZoom); toSprite.rotation = -2 * Math.PI * (1 - progress); toSprite.alpha = progress; break; case 'spiralBlur': fromSprite.alpha = 1 - progress; fromSprite.rotation = progress * Math.PI * 2; fromSprite.scale.set(fromScale * (1 - progress * 0.3) * dynamicZoom); toSprite.scale.set(((toScale * 0.3) + (toScale * 0.7 * progress)) * dynamicZoom); toSprite.alpha = progress; toSprite.x = (toX + this.canvasWidth) - (this.canvasWidth * progress); toSprite.rotation = (1 - progress) * Math.PI * 4; break; case 'waveSlide': const waveOffset = Math.sin(progress * Math.PI * 6) * 20 * (1 - progress); fromSprite.x = fromX + (this.canvasWidth * progress); fromSprite.y = fromY + waveOffset; fromSprite.alpha = 1 - progress; fromSprite.skew.x = progress * 0.3; toSprite.x = (toX - this.canvasWidth) + (this.canvasWidth * progress); toSprite.y = toY - waveOffset; toSprite.alpha = progress; toSprite.skew.x = (1 - progress) * 0.3; fromSprite.scale.set(fromScale * dynamicZoom); toSprite.scale.set(toScale * dynamicZoom); break; case 'liquidMorph': fromSprite.alpha = 1 - progress; fromSprite.scale.set(fromScale * (1 + progress * 0.3) * dynamicZoom); fromSprite.skew.x = Math.sin(progress * Math.PI * 2) * 0.3; toSprite.scale.set(((toScale * 2) - toScale * progress) * dynamicZoom); toSprite.alpha = 0.3 + (progress * 0.7); toSprite.skew.y = Math.cos(progress * Math.PI * 3) * 0.2; break; case 'shatterTransition': fromSprite.alpha = 1 - progress; fromSprite.rotation = progress * Math.PI * 0.5; fromSprite.scale.set(fromScale * (1 - progress * 0.2) * dynamicZoom); toSprite.scale.set(((toScale * 0.5) + (toScale * 0.5 * progress)) * dynamicZoom); toSprite.alpha = progress; toSprite.x = toSprite.x + (toX - toSprite.x) * progress; toSprite.y = toSprite.y + (toY - toSprite.y) * progress; toSprite.rotation = toSprite.rotation * (1 - progress); break; case 'windBlur': const windIntensity = Math.sin(progress * Math.PI) * 1.5; fromSprite.alpha = 1 - progress; fromSprite.skew.x = windIntensity * 0.1; fromSprite.x = fromX + windIntensity * 20; fromSprite.y = fromY + Math.sin(progress * Math.PI * 4) * 10; toSprite.x = (toX + this.canvasWidth * 0.8) - (this.canvasWidth * 0.8 * progress); toSprite.y = (toY - this.canvasHeight * 0.3) + (this.canvasHeight * 0.3 * progress); toSprite.alpha = progress; toSprite.skew.x = -(1 - progress) * 0.2; fromSprite.scale.set(fromScale * dynamicZoom); toSprite.scale.set(toScale * dynamicZoom); break; case 'orbitalSlide': fromSprite.alpha = 1 - progress; fromSprite.rotation = progress * Math.PI; const startAngle = Math.atan2(toSprite.y - toY, toSprite.x - toX); const currentAngle = startAngle * (1 - progress); const currentRadius = this.canvasWidth * 1.2 * (1 - progress); toSprite.x = toX + Math.cos(currentAngle) * currentRadius; toSprite.y = toY + Math.sin(currentAngle) * currentRadius; toSprite.alpha = progress; toSprite.rotation = currentAngle + (2 * Math.PI * progress); fromSprite.scale.set(fromScale * dynamicZoom); toSprite.scale.set(toScale * dynamicZoom); break; case 'shearSlideLeft': fromSprite.skew.x = -progress * 0.7; fromSprite.alpha = 1 - progress; toSprite.skew.x = (1 - progress) * 0.7; toSprite.alpha = progress; fromSprite.scale.set(fromScale * dynamicZoom); toSprite.scale.set(toScale * dynamicZoom); break; case 'shearSlideRight': fromSprite.skew.x = progress * 0.7; fromSprite.alpha = 1 - progress; toSprite.skew.x = -(1 - progress) * 0.7; toSprite.alpha = progress; fromSprite.scale.set(fromScale * dynamicZoom); toSprite.scale.set(toScale * dynamicZoom); break; case 'shearSlideUp': fromSprite.skew.y = -progress * 0.7; fromSprite.alpha = 1 - progress; toSprite.skew.y = (1 - progress) * 0.7; toSprite.alpha = progress; fromSprite.scale.set(fromScale * dynamicZoom); toSprite.scale.set(toScale * dynamicZoom); break; case 'shearSlideDown': fromSprite.skew.y = progress * 0.7; fromSprite.alpha = 1 - progress; toSprite.skew.y = -(1 - progress) * 0.7; toSprite.alpha = progress; fromSprite.scale.set(fromScale * dynamicZoom); toSprite.scale.set(toScale * dynamicZoom); break; default: fromSprite.alpha = 1 - progress; toSprite.alpha = progress; break; } }
    calculateAnimationValues(animationType) { const intensity = this.continuousIntensity * this.animationAmplitude; const time = this.continuousAnimationTime; let scale = this.baseImageScale, x = this.baseImageX, y = this.baseImageY, rotation = 0; let skew = { x: 0, y: 0 }; switch (animationType) { case 'focalDrift': const driftSpeedX = 0.3, driftSpeedY = 0.5, focusSpeed = 0.2; x = this.baseImageX + Math.sin(time * driftSpeedX + this.animationPhase) * 12 * intensity; y = this.baseImageY + Math.cos(time * driftSpeedY + this.animationPhase * 1.2) * 8 * intensity; scale = this.baseImageScale * (1 + Math.sin(time * focusSpeed + this.animationPhase * 1.5) * 0.05 * intensity); break; case 'gentleDrift': x = this.baseImageX + Math.cos(time * 0.6 + this.animationPhase) * 8 * intensity; y = this.baseImageY + Math.sin(time * 0.8 + this.animationPhase) * 6 * intensity; break; case 'smoothFloat': y = this.baseImageY + Math.sin(time * 1.1 + this.animationPhase) * 10 * intensity; scale = this.baseImageScale * (1 + Math.cos(time * 1.5) * 0.025 * intensity); break; case 'gentleSpin': rotation = Math.sin(time * 0.5 + this.animationPhase) * 0.08 * intensity; scale = this.baseImageScale * (1 + Math.cos(time * 1.8) * 0.03 * intensity); break; case 'breathingZoom': scale = this.baseImageScale * (1 + Math.sin(time * 1.5 + this.animationPhase) * 0.06 * intensity); break; case 'orbitalDrift': const orbitRadius = 15 * intensity; x = this.baseImageX + Math.cos(time * 0.8 + this.animationPhase) * orbitRadius; y = this.baseImageY + Math.sin(time * 1.1 + this.animationPhase) * orbitRadius * 0.7; scale = this.baseImageScale * (1 + Math.sin(time * 2) * 0.03 * intensity); break; case 'magneticPendulum': rotation = Math.sin(time * 1.2 + this.animationPhase) * 0.12 * intensity; x = this.baseImageX + Math.cos(time * 0.6) * 10 * intensity; break; case 'pulseWave': const pulseIntensity = Math.sin(time * 3 + this.animationPhase); scale = this.baseImageScale * (1 + pulseIntensity * 0.08 * intensity); rotation = pulseIntensity * 0.05 * intensity; break; case 'elasticFloat': y = this.baseImageY + Math.sin(time * 1.8 + this.animationPhase) * 20 * intensity; scale = this.baseImageScale * (1 + Math.cos(time * 2.5) * 0.04 * intensity); skew.x = Math.sin(time * 1.3) * 0.1 * intensity; break; case 'hypnoticSpin': rotation = Math.sin(time * 0.8 + this.animationPhase) * 0.15 * intensity; scale = this.baseImageScale * (1 + Math.cos(time * 2.2) * 0.05 * intensity); break; case 'liquidBreathing': scale = this.baseImageScale * (1 + Math.sin(time * 1.1 + this.animationPhase) * 0.07 * intensity); skew.x = Math.sin(time * 1.4) * 0.08 * intensity; skew.y = Math.cos(time * 1.7) * 0.05 * intensity; break; case 'cosmicDrift': const cosmicRadius = 25 * intensity, cosmicAngle = time * 0.3 + this.animationPhase; x = this.baseImageX + Math.cos(cosmicAngle) * cosmicRadius; y = this.baseImageY + Math.sin(cosmicAngle * 1.4) * cosmicRadius * 0.6; scale = this.baseImageScale * (1 + Math.sin(time * 1.6) * 0.04 * intensity); rotation = Math.sin(time * 0.7) * 0.08 * intensity; break; case 'heartbeat': const heartBeat = Math.max(0, Math.sin(time * 4 + this.animationPhase)); scale = this.baseImageScale * (1 + heartBeat * 0.12 * intensity); break; case 'windSway': x = this.baseImageX + Math.sin(time * 0.9 + this.animationPhase) * 18 * intensity; rotation = Math.sin(time * 1.1) * 0.1 * intensity; scale = this.baseImageScale * (1 + Math.cos(time * 1.5) * 0.03 * intensity); break; case 'oceanWave': x = this.baseImageX + Math.sin(time * 1.2 + this.animationPhase) * 12 * intensity; y = this.baseImageY + Math.cos(time * 0.8 + this.animationPhase) * 8 * intensity; scale = this.baseImageScale * (1 + Math.sin(time * 2.1) * 0.05 * intensity); skew.x = Math.sin(time * 1.4) * 0.06 * intensity; break; } return { scale, x, y, rotation, skew }; }
    setupTransitionInitialState(fromData, toData, transitionType) { const { sprite: fromSprite } = fromData; const { sprite: toSprite } = toData; fromSprite.alpha = 1; fromSprite.rotation = 0; fromSprite.skew.set(0); fromSprite.scale.set(fromData.baseScale); fromSprite.x = fromData.baseX; fromSprite.y = fromData.baseY; toSprite.alpha = 0; toSprite.rotation = 0; toSprite.skew.set(0); toSprite.scale.set(toData.baseScale); switch (transitionType) { case 'smoothSlideLeft': toSprite.x = toData.baseX + this.canvasWidth; toSprite.y = toData.baseY; break; case 'smoothSlideRight': toSprite.x = toData.baseX - this.canvasWidth; toSprite.y = toData.baseY; break; case 'smoothSlideUp': toSprite.x = toData.baseX; toSprite.y = toData.baseY + this.canvasHeight; break; case 'smoothSlideDown': toSprite.x = toData.baseX; toSprite.y = toData.baseY - this.canvasHeight; break; case 'zoomCrossfade': toSprite.x = toData.baseX; toSprite.y = toData.baseY; toSprite.scale.set(toData.baseScale * 0.8); break; case 'rotateZoom': toSprite.x = toData.baseX; toSprite.y = toData.baseY; toSprite.scale.set(toData.baseScale * 0.7); toSprite.rotation = Math.PI * 0.5; break; case 'scaleSlide': toSprite.x = toData.baseX + this.canvasWidth * 0.5; toSprite.y = toData.baseY; toSprite.scale.set(toData.baseScale * 0.6); break; case 'blurCrossfade': toSprite.x = toData.baseX; toSprite.y = toData.baseY; toSprite.scale.set(toData.baseScale * 1.1); break; case 'explosiveZoomIn': toSprite.scale.set(toData.baseScale * 0.1); toSprite.x = toData.baseX; toSprite.y = toData.baseY; toSprite.rotation = Math.PI * 2; break; case 'explosiveZoomOut': toSprite.scale.set(toData.baseScale * 3); toSprite.x = toData.baseX; toSprite.y = toData.baseY; toSprite.rotation = -Math.PI * 2; break; case 'spiralBlur': toSprite.scale.set(toData.baseScale * 0.3); toSprite.x = toData.baseX + this.canvasWidth; toSprite.y = toData.baseY; toSprite.rotation = Math.PI * 4; break; case 'waveSlide': toSprite.scale.set(toData.baseScale); toSprite.x = toData.baseX - this.canvasWidth; toSprite.y = toData.baseY; break; case 'liquidMorph': toSprite.scale.set(toData.baseScale * 2); toSprite.x = toData.baseX; toSprite.y = toData.baseY; toSprite.alpha = 0.3; break; case 'shatterTransition': toSprite.scale.set(toData.baseScale * 0.5); toSprite.x = toData.baseX + (Math.random() - 0.5) * this.canvasWidth; toSprite.y = toData.baseY + (Math.random() - 0.5) * this.canvasHeight; toSprite.rotation = Math.random() * Math.PI; break; case 'windBlur': toSprite.scale.set(toData.baseScale); toSprite.x = toData.baseX + this.canvasWidth * 0.8; toSprite.y = toData.baseY - this.canvasHeight * 0.3; break; case 'orbitalSlide': const angle = Math.random() * Math.PI * 2, radius = this.canvasWidth * 1.2; toSprite.scale.set(toData.baseScale); toSprite.x = toData.baseX + Math.cos(angle) * radius; toSprite.y = toData.baseY + Math.sin(angle) * radius; toSprite.rotation = angle; break; default: toSprite.x = toData.baseX; toSprite.y = toData.baseY; break; } }
    easeOutQuart(t) { return 1 - Math.pow(1 - t, 4); }
    easeOutExpo(t) { return t === 1 ? 1 : 1 - Math.pow(2, -10 * t); }
    easeInOutBack(t) { const c1 = 1.70158, c2 = c1 * 1.525; return t < 0.5 ? (Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2)) / 2 : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2; }
    easeOutBounce(t) { const n1 = 7.5625, d1 = 2.75; if (t < 1 / d1) return n1 * t * t; else if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75; else if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375; else return n1 * (t -= 2.625 / d1) * t + 0.984375; }
    getTransitionEasing(type, t) { switch (type) { case 'explosiveZoomIn': case 'explosiveZoomOut': return this.easeOutExpo(t); case 'spiralBlur': case 'liquidMorph': return this.easeInOutBack(t); case 'shatterTransition': return this.easeOutBounce(t); default: return this.easeOutQuart(t); } }
}